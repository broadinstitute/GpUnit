<?xml version="1.0" encoding="UTF-8"?>
<project name="gp-unit" basedir="." default="package"
    xmlns:if="ant:if"
    xmlns:unless="ant:unless"
    xmlns:artifact="antlib:org.apache.maven.artifact.ant"
>
    <dirname property="project.basedir" file="${ant.file.gp-unit}" />
    <property file="${project.basedir}/gpunit.default.properties" />
    <dirname property="gpunit.dir" file="${ant.file.gp-unit}" />
    <!-- 
      - Always load the 'gpunit.default.properties' file first, then
      - load the gpunit.properties file, which can optionally be
      - replaced with a different file, e.g.
      -      '-Dgpunit.properties=my.gpunit.properties'
      - NOTE: The GpUnit code in BatchProperties.java implements this
      - same behavior (loading gpunit.default.properties followed by
      - whatever other file is specified). Any change to the sequence
      - made here should be reflected there as well.
     -->
    <property name="gpunit.properties" value="${project.basedir}/gpunit.properties" />
    <property file="${gpunit.properties}" />

    <property name="gp.scheme" value="http" />
    <property name="gp.host" value="127.0.0.1" />
    <property name="gp.port" value="" />
    <property name="gp.path" value="/gp" />
    <property name="gp.user" value="test" />
    <property name="gp.password" value="test" />

    <property name="gp.url" value="${gp.scheme}://${gp.host}${gp.port}" />
    <property name="local.dir" location="${gpunit.dir}/tmp/${gp.host}" />
    <property name="client.lib.dir" location="${local.dir}/client" />
    <!-- if the client.dir already exists, skip the rest -->
    <available property="gp-client-lib-exists" file="${client.lib.dir}/GenePattern.jar" />
    <!-- location for downloading job results -->
    <property name="gpunit.outputdir" value="${local.dir}/jobResults" />
    <!-- location for generating junit reports -->
    <property name="report.dir" value="${user.dir}/reports" />

    <!-- optionally set junit jvm arg when testing an HTTPS server,
         -Djavax.net.ssl.trustStore=${gpunit.trustStore} 
         -Djavax.net.ssl.trustStorePassword=${gpunit.trustStorePassword}
    -->    
    <property name="gpunit.trustStore" value="" />
    <property name="gpunit.trustStorePassword" value="" />
    
    <path id="gp.client.classpath">
        <pathelement location="${client.lib.dir}/GenePattern.jar" />
        <fileset dir="${client.lib.dir}/lib">
            <include name="**/*.jar"/>
        </fileset>
    </path>

    <path id="gpunit.classpath">
        <pathelement location="${gpunit.dir}/classes"/>
        <fileset dir="${gpunit.dir}/lib">
            <include name="**/*.jar"/>
        </fileset>
        <path refid="gp.client.classpath" />
    </path>

    <!-- 
      Convenience target to set the dry-run flag from the command line
      Usage:
          ant dry-run actual-target
    -->
    <target name="dry-run" description="set dry-run flag, e.g. ant dry-run upload-files">
        <property name="dry-run" value="true" />
    </target>

    <!--
      debug 'dry-run' target
      Usage:
        ant dry-run         test-dry-run
        ant -Ddry-run=true  test-dry-run
        ant -Ddry-run=false test-dry-run
        ant -Ddry-run=""    test-dry-run
    -->
    <target name="debug-dry-run"
        description="debug 'dry-run' target"
    >
        <echo     if:set="dry-run"     >'dry-run' is set, dry-run='${dry-run}'</echo>
        <echo unless:set="dry-run"     >'dry-run' is not set</echo>
        <echo     if:true="${dry-run}" >'dry-run' is true</echo>
        <echo unless:true="${dry-run}" >'dry-run' is not true</echo>
    </target>

    <!--
      Set 'verbose' flag as an ant target
      Usage:
        ant verbose target[s] ...
      This is equivalent to 
        ant -Dverbose=true target[s] ...
      
      Note: this target is unnecessary when running ant in debug or verbose mode
        ant -debug, -d ...
        ant -verbose, -v ...
    -->
    <target name="verbose"
      description="set 'verbose' flag; ant verbose ...">
        <property name="verbose" value="true" />
    </target>

    <!-- 
      Enable verbose output
          ant -Dverbose=true ...
      As a convenience, also set to true, based on ant command line flags
          ant -v (-verbose) ...
          ant -d (-debug) ...

      Note: Use the 'echoproperties' task for extended debugging, e.g.
          <echoproperties destfile="echoproperties.out" />
      Note: To print the current command line
          <echo message="${sun.java.command}" />
    -->
    <target name="init-verbose">
        <condition property="verbose">
            <or>
                <istrue value="${verbose}" />
                <contains string="${sun.java.command}" substring=" -v " />
                <contains string="${sun.java.command}" substring=" -verbose " />
                <contains string="${sun.java.command}" substring=" -d " />
                <contains string="${sun.java.command}" substring=" -debug " />
            </or>
        </condition>
        <echo if:true="${verbose}" message="verbose='${verbose}'" />
    </target>

    <!--
      Apache Commons Logging configuration for HttpClient
        see: https://hc.apache.org/httpcomponents-client-ga/logging.html
    -->
    <target name="init-logging">
        <!-- Note: change 'ERROR' to 'DEBUG' for more detailed output -->
        <property name="org.apache.commons.logging.Log" value="org.apache.commons.logging.impl.SimpleLog" />
        <property name="org.apache.commons.logging.simplelog.showdatetime" value="true" />
        <property name="org.apache.commons.logging.simplelog.log.org.apache.http" value="ERROR" />
        <property name="org.apache.commons.logging.simplelog.log.org.apache.http.wire" value="ERROR" />
        <propertyset id="org.apache.commons.props">
            <propertyref prefix="org.apache.commons" />
        </propertyset>
    </target>

    <target name="init" depends="init-verbose, init-logging">
        <echo>initializing directories ... </echo>
        <echo>local.dir: ${local.dir} </echo>
        <echo>report.dir: ${report.dir} </echo>

        <tstamp />
        <mkdir dir="${gpunit.dir}/classes" />
        <mkdir dir="${gpunit.dir}/dist" />
        <mkdir dir="${client.lib.dir}" />
        <mkdir dir="${report.dir}" />
        
        <!-- initialize properties for a batch run -->
        <property name="gpunit.client" value="REST" />
        <property name="gpunit.batch.name" value="run_${DSTAMP}_${TSTAMP}" />
        <property name="gpunit.save.downloads" value="false" />
        <property name="gpunit.delete.jobs" value="false" />
        <property name="report.run.dir" location="${report.dir}/${gpunit.batch.name}" />
        <mkdir dir="${report.run.dir}" />
        <symlink link="${report.dir}/current" resource="${report.run.dir}" overwrite="true" failonerror="false" />
        <mkdir dir="${gpunit.outputdir}" />
        <symlink link="${gpunit.outputdir}/current" resource="${gpunit.batch.name}" overwrite="true" failonerror="false" />
        
        <property name="gpunit.upload.dir" value="" />
        <property name="gpunit.server.dir" value="" />
        
        <property name="gpunit.numThreads" value="" />
        <!-- timeout intervals in seconds, when set to the empty string, use default values built into GpUnit -->
        <property name="gpunit.shutdownTimeout" value="" /> <!-- Global timeout, exit junit after this timeout period. -->
        <property name="gpunit.jobCompletionTimeout" value="" /> <!-- Job poll timeout, stop polling for GP job completion after this timeout -->
        <property name="gpunit.testTimeout" value="" /> <!-- Junit test timeout, fail an indidivual junit test when this timeout is reached -->
        
        <has-value pname="gpunit.trustStore" />
        <has-value pname="gpunit.trustStorePassword" />
        
        <property name="gpunit.testData" value="ftp://gpftp.broadinstitute.org" />
        <property name="gpunit.gpData" value="ftp://ftp.broadinstitute.org/pub/genepattern/datasets" />
    </target>

    <target name="help" depends="init, init-testcases"
        description="init and print gpunit.properties"
    >
        <!-- retrieve environment variables -->
        <property environment="env" />
        
        <echo-value pname="env.ANT_HOME" />
        <echo-value pname="ant.version" />
        
        <echo-value pname="env.GPUNIT_HOME" />
        <echo-value pname="gpunit.dir" />
        <echo-value pname="basedir" />
        <echo-value pname="project.basedir" />
        <echo-value pname="user.dir" />
        <echo></echo>
        <echo-value pname="gpunit.properties" />
        
        <echo-value pname="client.lib.dir" />
        <echo></echo>
        <echo-value pname="connection-test.skip" />
        <echo-value pname="check-url.skip" />
        <echo-value pname="gpunit.numThreads" />
        <echo-value pname="gpunit.jobCompletionTimeout" />
        <echo-value pname="gpunit.testTimeout" />
        <echo-value pname="gpunit.shutdownTimeout" />
        <echo></echo>
        <echo-value pname="local.dir" />
        <echo-value pname="gpunit.outputdir" />
        <echo-value pname="gpunit.save.downloads" />
        <echo-value pname="gpunit.delete.jobs" />
        <echo></echo>
        <echo-value pname="report.dir" />
        <echo-value pname="gpunit.batch.name" />
        <echo-value pname="report.run.dir" />
        <echo></echo>
        <echo-value pname="gpunit.localAssertions" />
        <echo-value pname="gpunit.upload.dir" />
        <echo-value pname="gpunit.server.dir" />
        <!-- Data set locations -->
        <echo-value pname="gpunit.testData" />
        <echo-value pname="gpunit.gpData" />
        <echo-value pname="gpunit.diffStripTrailingCR" />
        <echo></echo>
        <echo-value pname="gp.url" />
        <echo-value pname="gp.path" />
        <echo-value pname="gp.user" />
        <!-- echo-value pname="gp.password" / -->
        <echo-value pname="gpunit.client" />
        <echo></echo>
        <echo-value pname="git.parentdir" />
        <echo></echo>
        <echo-value pname="gpunit.testfolder" />
        <echo-value pname="gpunit.includes" />
        <echo-value pname="gpunit.regexsuffix" />
        <echo-value pname="gpunit.dirprefix" />
        <echo-value pname="gpunit.testcases" />
    </target>
    
    <target name="debug-java.version">
        <echo-value pname="java.version" />
        <echo-value pname="ant.java.version" />
        <echo-value pname="env.JAVA_HOME" />
    </target>

    <!-- 
      Macrodef: has-value, to check for empty values
      Usage:
        <has-value pname="my-param" />
        <echo if:set="my_param.has_value">my_param is set to: ${my_param}</echo>
      Sets @{pname}.has_value to "true" if the parameter is set to a non-empty value.
      This is a workaround for incorrect (imho) implementation of if:blank and unless:blank
    -->
    <macrodef name="has-value">
        <attribute name="pname" />
        <attribute name="suffix" default=".has_value" />
        <sequential>
            <property name="@{pname}@{suffix}" value="true" if:set="@{pname}" unless:blank="${@{pname}}" />
        </sequential>
    </macrodef>

    <!--
      Macrodef: echo-value, print the value of the given property, 
        with special handling for unset, empty and boolean values.
        This is split into two macrodefs to enable verbose output.
      Usage:
        <echo-value pname="my-param" />
    -->
    <macrodef name="echo-value">
        <attribute name="pname" />
        <attribute name="suffix" default=".has_value" />
        <attribute name="pad" default="" />
        <sequential>
            <has-value pname="@{pname}" suffix="@{suffix}" />
            <echo-value-succint pname="@{pname}" pad="@{pad}" />
            <echo-value-verbose if:set="verbose" pname="@{pname}" suffix="@{suffix}" pad="@{pad}" />
        </sequential>
    </macrodef>

    <!-- don't call this directly, it is called from the 'echo-value' macrodef -->
    <macrodef name="echo-value-succint">
        <attribute name="pname" />
        <attribute name="pad" default="" />
        <sequential>
            <echo if:set="@{pname}">@{pad}@{pname}='${@{pname}}'</echo>
            <echo unless:set="@{pname}">@{pad}@{pname}=(not set)</echo>
        </sequential>
    </macrodef>

    <!-- 
      don't call this directly, it is called from the 'echo-value' macrodef
      when in verbose mode
      -->
    <macrodef name="echo-value-verbose">
        <attribute name="pname" />
        <attribute name="suffix" default=".has_value" />
        <attribute name="pad" default="    " />
        <sequential>
            <echo       if:set="@{pname}"    >@{pad}if:set="@{pname}"</echo>
            <echo   unless:set="@{pname}"    >@{pad}unless:set="@{pname}"</echo>
            <echo      if:true="${@{pname}}" >@{pad}if:true="$${@{pname}}"</echo>
            <echo  unless:true="${@{pname}}" >@{pad}unless:true="$${@{pname}}"</echo>
            <echo     if:blank="${@{pname}}" >@{pad}if:blank="$${@{pname}}"</echo>
            <echo unless:blank="${@{pname}}" >@{pad}unless:blank="$${@{pname}}"</echo>
            <!-- for illustration only, incorrect use of if:blank ... 
            <echo     if:blank="@{pname}"    >@{pad}if:blank="@{pname}"</echo>
            <echo unless:blank="@{pname}"    >@{pad}unless:blank="@{pname}"</echo>
            -->
            
            <!-- recommended, if:set="gpunit.trustStore.has_value" ... -->
            <echo>@{pad}is '@{pname}' set ...</echo>
            <!-- echo>@{pad}recommended ...</echo -->
            <echo       if:set="@{pname}@{suffix}"    >@{pad}    (recommended) if:set="@{pname}@{suffix}"</echo>
            <echo   unless:set="@{pname}@{suffix}"    >@{pad}    (recommended) unless:set="@{pname}@{suffix}"</echo>
            <!-- alternative 1, if:true"${gpunit.trustStore.has_value}" ... -->
            <!-- echo>@{pad}alternative 1 ...</echo -->
            <echo      if:true="${@{pname}@{suffix}}" >@{pad}          (alt 1) if:true="$${@{pname}@{suffix}}"</echo>
            <echo  unless:true="${@{pname}@{suffix}}" >@{pad}          (alt 1) unless:true="$${@{pname}@{suffix}}"</echo>
            <!-- alternative 2, does not require 'has-value' macrodef
                 if:set="gpunit.trustStore" unless:blank="${gpunit.trustStore}" ...  -->
            <!-- echo>@{pad}alternative 2 ... </echo -->
            <echo if:set="@{pname}" unless:blank="${@{pname}}">@{pad}          (alt 2) if:set="@{pname}" unless:blank="$${@{pname}}"</echo>
        </sequential>
    </macrodef>

    <!-- 
      Macrodef: fq-path, to convert a relative to an absolute file path;
        by default, paths are converted to fully qualified paths
          relative to the 'user.dir' instead of the 'basedir'.
      Usage:
        <property name="my_path" value="a/relative/dir" />
        <fq-path pname="my_path" />
        <echo>my_path.fq_name: ${my_path.fq_name}</echo>
      Output:
        '@{pname}.is_set'      "true" when pname references an actual property 
        '@{pname}.is_relative' "true" when the path is relative
        '@{pname}.fq_path'     the fully qualified path relative to the custom basedir.
        '@{pname}.is_file'     "true" when the path is to a file
        '@{pname}.is_dir'      "true" when the path is to a directory
        '@{pname}.exists'      "true" when the file or directory exists
        
      Note: All of this is a workaround because I would like to treat relative paths as
        being relative to the working directory instead of the ant basedir.
    -->
    <macrodef name="fq-path">
        <attribute name="pname" 
            description="the name of a property to convert" />
        <attribute name="prefix" default="${user.dir}" 
            description="(optional) path prefix to append to relative paths" />
        <attribute name="debug" default="" />
        <sequential>
            <!-- set 'is_set' -->
            <property name="@{pname}.is_set" value="true" if:set="@{pname}" />

            <!-- set 'is_relative', by comparing property by 'location' with relative='true' and 'false'
                   See: https://ant.apache.org/manual/Tasks/property.html
            -->
            <local name="tmp.location" />
            <local name="tmp.relative" />
            <property name="tmp.location" location="${@{pname}}" relative="false" />
            <property name="tmp.relative" location="${tmp.location}" relative="true" />
            <condition property="@{pname}.is_relative" value="true">
                <not><equals arg1="${@{pname}}" arg2="${tmp.location}" /></not>
            </condition>

            <!-- set 'fq_path', conditionally by 'is_relative'
                   See: https://ant.apache.org/manual/ifunless.html
            -->
            <property name="@{pname}.fq_path"     if:true="${@{pname}.is_relative}"
                location="@{prefix}/${tmp.relative}" />
            <property name="@{pname}.fq_path" unless:true="${@{pname}.is_relative}" 
                location="${tmp.location}" />

            <!-- set 'exists' -->
            <available property="@{pname}.exists" file="${@{pname}.fq_path}" />

            <!-- set 'is_dir' -->
            <available property="@{pname}.is_dir" file="${@{pname}.fq_path}" type="dir" />
            
            <!-- set 'is_file' -->
            <available property="@{pname}.is_file" file="${@{pname}.fq_path}" type="file" />

            <!-- debug output -->
            <echo       if:true="@{debug}" message="fq-path, @{pname}='${@{pname}}', ..." /> 
            <echo-value if:true="@{debug}" pname="@{pname}.fq_path"  pad="    " /> 
            <echo-value if:true="${debug}" pname="@{pname}.is_set" pad="    " /> 
            <echo-value if:true="${debug}" pname="@{pname}.exists" pad="    " /> 
            <echo-value if:true="${debug}" pname="@{pname}.is_file" pad="    " /> 
            <echo-value if:true="${debug}" pname="@{pname}.is_dir" pad="    " /> 
            <echo-value if:true="${debug}" pname="@{pname}.is_relative" pad="    " /> 
            <echo-value if:true="${debug}" pname="tmp.value" pad="    " /> 
            <echo-value if:true="${debug}" pname="tmp.location" pad="    " /> 
            <echo-value if:true="${debug}" pname="tmp.relative" pad="    " /> 
        </sequential>
    </macrodef>

    <target name="debug-fq-path"
        description="debug 'fq-path' macro (interactive)"
    >
        <property name="debug" value="true" />
        <input message="set -Dtest.dir=" addProperty="test.dir" defaultValue="gpunit" />
        <input message="set -Dtest.basedir=" addProperty="test.basedir" defaultValue="${user.dir}" />
        <input message="set -Ddebug=" addProperty="debug" validArgs=",true" defaultValue="" />
        <fq-path pname="test.dir" prefix="${test.basedir}" debug="${debug}" />
    </target>

    <target name="debug-fq-path-examples"
        description="debug 'fq-path' macro (examples)"
    >
        <property name="debug" value="true" />
        
        <!-- example: ${user.dir} -->
        <fq-path pname="user.dir" debug="${debug}" />
        <!-- example: ${basedir"} -->
        <fq-path pname="basedir"  debug="${debug}" />
        <!-- example: path to file -->
        <property name="test.filepath.abs" location="${gpunit.dir}/tests/protocols/01_Run/01_PreprocessDataset/test.yaml" />
        <fq-path pname="test.filepath.abs" debug="${debug}" />
        <!-- example: relative path to file -->
        <property name="test.filepath.rel" value="tests/protocols/01_Run/01_PreprocessDataset/test.yaml" />
        <fq-path pname="test.filepath.rel" debug="${debug}" />
        <!-- example: relative path -->
        <property name="test.default.01" value="tests/protocols" />
        <fq-path pname="test.default.01" debug="${debug}" />
        <!-- example: relative path with parent -->
        <property name="test.default.02" value="tests/protocols/../testGpUnit" />
        <fq-path pname="test.default.02" debug="${debug}" />
        <!-- example: relative to alt.basedir -->
        <property name="alt.basedir" location="tests/protocols" />
        <property name="test.alt.basedir.01" value="" />
        <fq-path pname="test.alt.basedir.01" prefix="${alt.basedir}" debug="${debug}" />
        <!-- example: relative to alt.basedir -->
        <property name="test.alt.basedir.02" value="05_SNP" />
        <fq-path pname="test.alt.basedir.02" prefix="${alt.basedir}" debug="${debug}" />
        <!-- example: relative to alt.basedir with parent -->
        <property name="test.alt.basedir.03" value="../testGpUnit" />
        <fq-path pname="test.alt.basedir.03" prefix="${alt.basedir}" debug="${debug}" />

        <!-- example: value not set -->
        <fq-path pname="test.not_set" debug="${debug}" />
        
        <!-- example: with 'test.dir' and 'test.basedir' properties -->
        <property name="test.dir" value="gpunit" />
        <property name="test.basedir" value="${user.dir}" />
        <fq-path pname="test.dir" prefix="${test.basedir}" debug="${debug}" />
    </target>

    <!--
      Macrodef: set-testcases
        Helper method to initialize the 'testcases' property to be used as 
      input to the 'run-tests' macro. 
        Scan for all *.yml, *.yaml, and 'gp_execution_log.txt' files
      in the current working directory.
      Can be customized to scan from a different base directory 
      with different file filters.

      Options:
        pname, the name of the property to set
          Default: 'testcases'
        dirprefix, the path prefix for relative paths
           Default: ${user.dir}
        dir, the base directory relative to 'dirprefix'
           Default: ''
        includes, the include filter
           Default: '**/*', match all
        regexsuffix, by default only *.yaml, *.yml, and 'gp_execution_log.txt' files are included
           Default: '.*(\.ya?ml|gp_execution_log\.txt)'
      Usage:
        <set-testcases pname="my.testcases" ... />
        <run-tests testcases="${my.testcases}" ... />
      Output:
        '@{pname}'
        '@{pname}.fileset'
        '@{pname}.fileset.formatted'
        '@{pname}.dir.[fq_path | is_dir | ...] ', same as set-fq-path
    -->
    <macrodef name="set-testcases">
        <!-- the name of the property to set, default: testcases -->
        <attribute name="pname" default="testcases" />
        <attribute name="dirprefix" default="${user.dir}" />
        <attribute name="dir" default="" /> <!-- the testcases.dir -->
        <attribute name="regexsuffix" default=".*(\.ya?ml|gp_execution_log\.txt)" />
        <attribute name="includes" default="**/*" />
        <attribute name="debug" default="" />

        <sequential>
            <property name="@{pname}.dir" value="@{dir}" />
            <fq-path pname="@{pname}.dir" prefix="@{dirprefix}" debug="${debug}" />
            <!-- special-case, it's not a directory -->
            <fileset id="@{pname}.fileset" file="${@{pname}.dir.fq_path}" if:set="@{pname}.dir.is_file" />
            <fileset id="@{pname}.fileset" dir="${@{pname}.dir.fq_path}" includes="@{includes}" if:set="@{pname}.dir.is_dir">
                <filename regex="@{regexsuffix}" />
            </fileset>
            <!-- set '@{pname}.fileset', for input to the gpunit macro -->
            <pathconvert property="@{pname}" refid="@{pname}.fileset" />
            <!-- set '@{pname}.fileset.formatted' for human readable display on the terminal -->
            <property name="@{pname}.fileset.formatted" if:set="@{pname}.dir.is_file" value="${@{pname}.dir.fq_path}" />
            <property name="pathsep" value="${line.separator}    " />
            <pathconvert property="@{pname}.fileset.formatted" if:set="@{pname}.dir.is_dir"
                refid="@{pname}.fileset"
                pathsep="${pathsep}" 
            >
                <map from="${@{pname}.dir.fq_path}" to=""/>
            </pathconvert>
            
            <!-- debugging -->
            <echo-value if:true="@{debug}" pname="@{pname}.dir" />
            <echo-value if:true="@{debug}" pname="@{pname}.dir.fq_path" />
            <echo if:true="@{debug}">@{pname}.fileset=${pathsep}${@{pname}.fileset.formatted}</echo>
            <!-- echo-value if:true="@{debug}" pname="@{pname}" / -->
        </sequential>
    </macrodef>

    <!--
      Macrodef: echo-testcases
        formatted output of the 'testcases' property
    -->
    <macrodef name="echo-testcases">
        <attribute name="pname" default="testcases" />
        <sequential>
            <echo-value if:set="@{pname}.dir.is_dir"  pname="@{pname}.dir" />
            <echo-value if:set="@{pname}.dir.is_dir"  pname="@{pname}.dir.fq_path" />
            <echo       if:set="@{pname}.dir.is_dir"
                >testcases.fileset=${pathsep}${@{pname}.fileset.formatted}</echo>
            <echo-value if:true="@{debug}" pname="@{pname}" />
        </sequential>
    </macrodef>

    <target name="echo-testcases"
        description="for debugging, echo the 'testcases' property">
        <echo-testcases pname="gpunit.testcases" />
    </target>

    <!--
      debug-set-testcases
    -->
    <target name="debug-set-testcases"
        description="debug 'set-testcases' macro (interactive)"
    >
        <property name="debug" value="true" />
        <input message="set 'pname'"       addProperty="pname"         defaultValue="testcases" />
        <input message="set 'dirprefix'"   addProperty="dirprefix"     defaultValue="${gpunit.dir}" />
        <input message="set 'dir'"         addProperty="dir"           defaultValue="tests/protocols" />
        <input message="set 'includes'"    addProperty="includes"      defaultValue="**/*" />
        <input message="set 'regexsuffix'" addProperty="regexsuffix"   defaultValue=".*(\.ya?ml|gp_execution_log\.txt)" />
        
        <set-testcases pname="${pname}" dirprefix="${dirprefix}" dir="${dir}" includes="${includes}" regexsuffix="${regexsuffix}" />
        <echo-testcases pname="${pname}" />
    </target>

    <!--
      debug-set-testcases-examples
        example 'set-testcases' usage.
    -->
    <target name="debug-set-testcases-examples" 
        description="for debugging 'set-testcases' macro"
    >
        <!-- example: a single test from a yaml file -->
        <set-testcases pname="testcases.from_file" dirprefix="${gpunit.dir}" dir="tests/protocols/01_Run/01_PreprocessDataset/test.yaml" />
        <echo-value pname="testcases.from_file" />

        <!-- example:  a list (aka suite) of tests from a parent directory -->
        <set-testcases pname="testcases.from_dir" dirprefix="${gpunit.dir}" dir="tests/protocols/01_Run" />
        <echo-value pname="testcases.from_dir" />

        <!-- example: includes filter -->
        <set-testcases pname="testcases.includes_01" dirprefix="${gpunit.dir}" dir="tests/protocols" includes="**/01_PreprocessDataset/**" />
        <echo-value pname="testcases.includes_01" />

        <!-- example: space separated includes -->
        <set-testcases pname="testcases.includes_02" dirprefix="${gpunit.dir}" dir="tests/protocols/02_Differential" includes="**/*.yaml **/*.yml" />
        <echo-value pname="testcases.includes_02" />

        <!-- example: comma separated includes -->
        <set-testcases pname="testcases.includes_03" dirprefix="${gpunit.dir}" dir="tests/protocols/02_Differential" includes="**/*.yml,**/*.yaml" />
        <echo-value pname="testcases.includes_03" />
    </target>

    <!--
      debug-fileset-examples
        for debugging only, this target shows a bunch of different ways
      to create a 'testcases' property directly (without the 'set-testcases' macrodef).
            The 'testcases' property can be ...
        ... a direct path to a test.yaml file
        ... a direct path to a test directory
        ... a list of one or more file paths, separated by the system java.io.File.pathSeparatorChar.
            See: https://docs.oracle.com/javase/7/docs/api/java/io/File.html#pathSeparatorChar

      Bash command to generate the -Dtestcases arg ...
        See: https://stackoverflow.com/questions/2915556/unix-replace-newline-w-colon-preserving-newline-before-eof
        
        # (linux)
        $ cd ./gpunit
        # take 1
        $ find "$(cd ..; pwd)" -regextype posix-extended -regex '.*\.(yml|yaml)' | tr '\n' ':' | sed '$s/.$//'
        # take 2
        $ echo $(find "$(cd ..; pwd)" -regex '.*\.ya?ml' | tr '\n' ':' | head -c -1)
        # take 3
        $ find "$(cd ..; pwd)" -regex '.*\.ya?ml' | tr '\n' ':' | sed 's/:$/\n/'
        
        # (mac os x) 
        #   note: workaround for '\n' with sed on mac os x
        $ cd ./gpunit
        $ find -E `pwd` -regex '.*\.ya?ml' | tr '\n' ':' | sed -e 's/\(.*\):/\1/'
        
        # Example regex, skip child directories
        # (mac os x)
        $ find -E `pwd` -regex `pwd`'/[^/]*'
      
    -->
    <target name="demo-testcases-from-fileset" 
        description="for debugging, example ant filesets"
    > 
        <!-- example: a single testcase file -->
        <property name="testcases.file" location="${gpunit.dir}/tests/protocols/01_Run/01_PreprocessDataset/test.yaml" />
        <echo-value pname="testcases.file" />

        <!-- example: a single testcase directory -->
        <property name="testcases.dir" location="${gpunit.dir}/tests/protocols" />
        <echo-value pname="testcases.dir" />

        <!--
          example: a list of directories from a dirset
          must use pathconvert
        -->
        <dirset id="example.dirset" dir="${gpunit.dir}/tests">
            <include name="protocols/03_*" />
            <include name="protocols/04_*" />
        </dirset>
        <pathconvert property="testcases.from_dirset" refid="example.dirset" />
        <echo-value pname="testcases.from_dirset" />

        <!-- 
          example: a path-like structure
          see: http://ant.apache.org/manual/using.html#path
        -->
        <path id="example.path">
            <pathelement location="${gpunit.dir}/tests/protocols/01_Run/02_HeatMapViewer/test.yaml" />
            <pathelement location="${gpunit.dir}/tests/protocols/03_Clustering" />
        </path>
        <pathconvert property="testcases.from_path" refid="example.path" /> 
        <echo-value pname="testcases.from_path" />

        <!-- example: a fileset -->
        <fileset id="example.fileset" dir="${gpunit.dir}/tests/protocols/01_Run">
            <include name="**/*.yaml" />
            <include name="**/*.yml" />
        </fileset>
        <pathconvert property="testcases.from_fileset" refid="example.fileset" /> 
        <echo-value pname="testcases.from_fileset" />

        <!-- example: 'saved_jobs' fileset -->
        <fileset id="saved_jobs.fileset" dir="${gpunit.dir}/tests/saved_jobs">
            <include name="**/*.yaml" />
            <include name="**/*.yml" />
            <include name="**/gp_execution_log.txt" />
        </fileset>
        <pathconvert property="testcases.saved_jobs" refid="saved_jobs.fileset" /> 
        <echo-value pname="testcases.saved_jobs" />
    </target>

    <!--
      Macrodef: git-shallow-clone
        Makes a shallow clone of the remote repository into a target directory
        on the local file system.
      Template:
        cd {parentdir}
        git clone [-b [{branch}] {urlPrefix}/{name}
        
      GitHub Url Template:
        @see: https://help.github.com/articles/changing-a-remote-s-url/
          origin  https://github.com/USERNAME/REPOSITORY.git (fetch)
          origin  git@github.com:USERNAME/REPOSITORY.git (fetch)
        urlPrefix := {github.url}/{github.organization}
        name := {github.repository}
        repository := {github.url}/{github.username}/{github.repository}
        repository := {urlPrefix}/{name}
        
      Uses the '-C <path>' option,
        Run as if git was started in <path> instead of the current working directory. 
      Command Template: --><?code
        # (initialize) shallow clone into a new target directory
          cd {parentdir}
          git clone --no-single-branch --depth 1 [--branch {branch}] {repo} {repo-name}
        # reset to a specific commit
          cd {parentdir}
          git -C {repo.name} fetch --depth 1
          git -C {repo.name} reset --hard {commit}
          git -C txt2odf clean -dfx
    ?><!--
    Example:  --><?code 
          cd target/ModuleTests
          git clone --no-single-branch --depth 1 --branch master https://github.com/genepattern/txt2odf txt2odf
          git -C txt2odf fetch --depth 1
          git -C txt2odf reset --hard origin/develop
          git -C txt2odf clean -dfx
    
    Example commits 
          origin/master
          origin/develop
          tags/v2
          tags/v0.3
    ?>
    <property name="git-shallow-clone.failonerror" value="false" />
    <macrodef name="git-shallow-clone">
        <attribute name="repo" 
            description="the full url to a github repository, including the trailing '.git'" />
        <attribute name="parentdir" default="${user.dir}" 
            description="the git working directory is created as a child of the parentdir"
        />
        <attribute name="branch" default="master" 
            description="the argument to the git clone --branch command, e.g. 'develop' or 'v0.1'"
        />
        <attribute name="commit" default="origin/@{branch}" 
            description="the argment to the git reset --hard command, e.g. 'origin/develop' or 'tags/v0.1'" 
        />
        <attribute name="failonerror" default="${git-shallow-clone.failonerror}" />

        <sequential>
            <echo message="repo='@{repo}'" />
            <echo message="branch='@{branch}'" />
            <echo message="commit='@{commit}'" />
            
            <local name="reponame" />
            <basename property="reponame" file="@{repo}" suffix=".git" />
            <local name="local.repo.dir" />
            <local name="local.repo.dir.exists" />
            <property name="local.repo.dir" location="@{parentdir}/${reponame}" />
            <available property="local.repo.dir.exists" file="${local.repo.dir}" />

            <echo message="reponame='${reponame}'" />

            <!-- shallow clone if the local repo does not exist -->
            <echo unless:set="local.repo.dir.exists">Cloning git repository: '@{repo}' (branch '@{branch}')</echo>
            <exec unless:set="local.repo.dir.exists" executable="git" dir="@{parentdir}" failonerror="@{failonerror}">
                <arg value="clone" />
                <!-- shallow clone -->
                <arg value="--no-single-branch" />
                <arg value="--depth" />
                <arg value="1" />
                <arg value="--branch" />
                <arg value="@{branch}" />
                <arg value="@{repo}" />
                <arg value="${reponame}" />
            </exec>

            <!-- shallow update: fetch -->
            <echo>git -C '${reponame}' fetch --depth 1</echo>
            <exec executable="git" dir="@{parentdir}" failonerror="@{failonerror}">
                <arg value="-C" /> <arg value="${reponame}" />
                <arg value="fetch" />
                <arg value="--depth" />
                <arg value= "1" />
            </exec>

            <!-- shallow update: reset -->
            <echo>git -C '${reponame}' reset --hard '@{commit}'</echo>
            <exec executable="git" dir="@{parentdir}" failonerror="@{failonerror}">
                <arg value="-C" /> <arg value="${reponame}" />
                <arg value="reset" />
                <arg value="--hard" /> 
                <arg value="@{commit}" />
            </exec>

            <!-- shallow update: clear -->
            <echo>git clean -dfx</echo>
            <exec executable="git" dir="@{parentdir}" failonerror="@{failonerror}">
                <arg line="-C" /> <arg line="${reponame}" />
                <arg line="clean" /> <arg line="-dfx" />
            </exec>
        </sequential>
    </macrodef>

    <target name="debug-git-clone" depends="init-git.parentdir"
        description="debug the 'git-shallow-clone' macro"
    >
        <property name="git.organization.url" value="https://github.com/genepattern" />
        <property name="repo.name" value="txt2odf" />
        <property name="git.repo" value="${git.organization.url}/${repo.name}.git" />
        <property name="git.branch" value="master" />
        <property name="git.commit" value="origin/${git.branch}" />
        <property name="git.failonerror" value="true" />

        <git-shallow-clone repo="${git.repo}" branch="${git.branch}" commit="${git.commit}" parentdir="${git.parentdir}" 
            failonerror="${git.failonerror}" 
        />
    </target>

    <property name="module.git.branch.name" value="master" />
    <!--
      Macrodef: clone-repo
        clone the remote repository into a target directory on the local file system.
    -->
    <macrodef name="clone-repo">
        <attribute name="git.organization.url" default="https://github.com/genepattern" />
        <attribute name="git.repo.name" />
        <attribute name="git.branch.name" default="${module.git.branch.name}" />
        <attribute name="git.origin.name" default="origin" />
        <attribute name="git.parentdir" default="${git.parentdir}" />
        <attribute name="git.failonerror" default="false" />

        <sequential> 
            <git-shallow-clone parentdir="@{git.parentdir}" 
                repo="@{git.organization.url}/@{git.repo.name}.git" 
                branch="@{git.branch.name}" 
                commit="@{git.origin.name}/@{git.branch.name}"
                failonerror="@{git.failonerror}" />
        </sequential>
    </macrodef>

    <target name="debug-clone-repo" depends="init-git.parentdir"
        description="debug the 'clone-repo' macro"
    >
        <property name="repo.name" value="txt2odf" />
        <property name="git.origin.name" value="origin" />
        <clone-repo git.repo.name="${repo.name}" git.origin.name="${git.origin.name}" git.parentdir="${git.parentdir}" />
    </target>

    <!--
      init-testcases
        set 'testcases' by scanning all *.y?ml files relative to a base directory ('gpunit.dirprefix').
      The basedir is determined from these rules:
          ${gpunit.dirprefix}              if 'gpunit.dirprefix' is set
          ${gpunit.testfolder}             if 'gpunit.testfolder' is set to an absolute path
          ${user.dir}/${gpunit.testfolder} if 'gpunit.testfolder' is set to a relative path
          ${user.dir}/${gpunit.dirname}    if ${user.dir}/${gpunit.dirname} exists
          ${user.dir}                      by default if no other rules apply
    -->
    <target name="init-testcases" depends="init-gpunit.dirprefix">
        <property name="gpunit.testfolder"   value="" />
        <property name="gpunit.includes"     value="**/*" />
        <property name="gpunit.regexsuffix" value=".*(\.ya?ml|gp_execution_log\.txt)" />
        <!-- fail if property not set -->
        <fail unless="gpunit.dirprefix" message="Missing required property 'gpunit.dirprefix'" />
        <set-testcases pname="gpunit.testcases" 
            dirprefix="${gpunit.dirprefix}" 
            dir="${gpunit.testfolder}" 
            includes="${gpunit.includes}" 
            regexsuffix="${gpunit.regexsuffix}" 
            debug="${dry-run}" 
        />
    </target>

    <!--
      Set the 'gpunit.dirprefix' to match the rules described in the 'init-testcases' target. 
      Options:
        gpunit.dirname, set an alternate name for the test directory
          Default: 'gpunit'
    -->
    <target name="init-gpunit.dirprefix">
        <!-- set default 'gpunit.dirname' -->
        <property name="gpunit.dirname" value="gpunit" />
        
        <!-- special-case: if gpunit folder exists -->
        <condition property="gpunit.dirprefix" value="${user.dir}/${gpunit.dirname}" else="${user.dir}">
            <and>
                <!-- ${user.dir}/gpunit exists -->
                <available file="${user.dir}/${gpunit.dirname}" type="dir" />
                <!-- and gpunit.testfolder is not set -->
                <or>
                    <not><isset property="gpunit.testfolder" /></not>
                    <equals arg1="" arg2="${gpunit.testfolder}" />
                </or>
            </and>
        </condition>
        <echo-value if:true="${debug}" pname="gpunit.testfolder" />
        <echo-value if:true="${debug}" pname="gpunit.dirname" />
        <echo-value if:true="${debug}" pname="gpunit.dirprefix" />
    </target>
 
    <!-- set the 'git.parentdir' property,
       the local path from which to run the git clone command
     to use as input to the git-shallow-clone macro 
      Template:
        cd {git.parentdir}
        git clone {repository}
      Example:
        cd ./target/ModuleTests
        git clone git@github.com:genepattern/txt2odf.git
    -->
    <property name="git.parentdir.default" location="${gpunit.dir}/target/ModuleTests" />
    <target name="init-git.parentdir">
        <!-- replacing 'module.tests.dir' with 'git.parentdir' -->
        <echo if:set="module.tests.dir">WARNING: 'module.tests.dir' is deprecated, use 'git.parentdir' instead</echo>
        <property name="git.parentdir" value="${module.tests.dir}" if:set="module.tests.dir" />
        <property name="git.parentdir" location="${gpunit.dir}/target/ModuleTests" />        
        <property name="git.parentdir" location="${user.dir}/ModuleTests" />

        <property name="debug" value="true" />
        <echo-value if:true="${debug}" pname="module.tests.dir" />
        <echo-value if:true="${debug}" pname="git.parentdir" />
        <mkdir dir="${git.parentdir}" />
    </target>

    <!-- set 'testcases' by pulling from the Git repository before scanning for matching yaml files -->
    <target name="init-testcases-git" depends="init-git.parentdir">
        <property name="git.organization.url" value="https://github.com/genepattern" />
        <property name="repo.name" value="txt2odf" />
        <property name="git.repo" value="${git.organization.url}/${repo.name}.git" />
        <property name="git.branch" value="master" />
        <property name="git.commit" value="origin/${git.branch}" />
        <property name="git.failonerror" value="false" />
        <property name="dry-run" value="false" />

        <git-shallow-clone repo="${git.repo}" branch="${git.branch}" commit="${git.commit}"  parentdir="${git.parentdir}" failonerror="${git.failonerror}" />

        <property name="gpunit.testfolder"   value="" />
        <property name="gpunit.includes"     value="**/*" />
        <property name="gpunit.regexsuffix" value=".*(\.ya?ml|gp_execution_log\.txt)" />
        <set-testcases pname="gpunit.testcases" dirprefix="${git.parentdir}" dir="${repo.name}/gpunit" 
            includes="${gpunit.includes}" 
            regexsuffix="${gpunit.regexsuffix}" 
            debug="${dry-run}" 
        /> 
    </target>

    <!--                                                                                                                                                               
      Test 'gpunit.trustStore' and 'gpunit.trustStorePassword' flags
      Usage: 
        ant -Dgpunit.trustStore=A debug-trustStore-flags
        ant -Dgpunit.trustStorePassword=B debug-trustStore-flags
    -->
    <target name="debug-trustStore-flags" depends="init"
        description="for debugging 'gpunit.trustStore' and 'gpunit.trustStorePassword' flags"
    >
        <!-- check if the verbose flag is set -->
        <condition property="verbose">
            <or>
                <contains string="${sun.java.command}" substring=" -v " />
                <contains string="${sun.java.command}" substring=" -verbose " />
            </or>
        </condition>
        <echo>verbose: ${verbose}</echo>

        <echo-value pname="gpunit.trustStore" />
        <echo if:set="gpunit.trustStore.has_value">    jvmarg: -Djavax.net.ssl.trustStore=${gpunit.trustStore}</echo>
        <echo unless:set="gpunit.trustStore.has_value">    jvmarg not set: -Djavax.net.ssl.trustStore</echo>
        <echo-value pname="gpunit.trustStorePassword" />
        <echo if:set="gpunit.trustStorePassword.has_value">    jvmarg: -Djavax.net.ssl.trustStorePassword=${gpunit.trustStorePassword}</echo>
        <echo unless:set="gpunit.trustStorePassword.has_value">    jvmarg not set: -Djavax.net.ssl.trustStorePassword</echo> 
    </target>

    <!--
        This target verifies that the gpunit client can talk to the remove server; 
        Added as a way to test that the client is properly configured to connect to HTTPS servers.
        Hint: Set -Dgpunit.trustStore when necessary.
    -->
    <target name="connection-test" depends="package, check-url" unless="connection-test.skip"
        description="Run the 'org.genepattern.gpunit.test.ConnectionTest' junit test">
        <echo>Checking connection ... </echo>
        <run-tests testcases="connection-test" junit.test.name="org.genepattern.gpunit.test.ConnectionTest" />
    </target>

    <target name="check-url" depends="init-verbose" unless="check-url.skip"
        description="check that the server is online, curl --head '${gp.url}' " >
        <check-url />
    </target>

    <!-- the (convoluted) ant way to optionally call <check-url /> before downloading the client library -->
    <condition property="gp-client-lib-check-url.skip">
        <or>
            <isTrue value="${gp-client-lib-exists}" />
            <isTrue value="${check-url.skip}" />
        </or>
    </condition>
    <target name="gp-client-lib-check-url" unless="gp-client-lib-check-url.skip">
        <check-url />
    </target>

    <!-- the gp-client-lib is needed to compile GpUnit -->
    <target name="gp-client-lib" depends="init, gp-client-lib-check-url" unless="gp-client-lib-exists"
        description="download the GenePattern Java Programming Library (SOAP client) from the server" >

        <get verbose="false" 
            src="${gp.url}${gp.path}/downloads/GenePattern.zip" 
            dest="${local.dir}/GenePattern.zip" usetimestamp="true" />
        <unzip src="${local.dir}/GenePattern.zip" dest="${client.lib.dir}" overwrite="true" />
    </target>

    <!-- location for maven dependencies copied into this project -->
    <property name="dependency.dir" location="${gpunit.dir}/target/dependency" />
    <target name="download-deps" depends="init" unless="download-deps.called"
        description="install maven dependencies"
    >
        <!-- workaround for java.lang.ClassCastException: org.codehaus.plexus.DefaultPlexusContainer -->
        <property name="download-deps.called" value="true" />
        <!--  
          Maven Ant Tasks > Dependencies 
            See: http://maven.apache.org/ant-tasks/reference.html#dependencies
            See: http://maven.apache.org/ant-tasks/examples/dependencies.html

          Note: must set custom 'dependencyRefsBuildFile'
            default: ./target/build-dependencies.xml
        -->
        <path id="maven-ant-tasks.classpath" path="${gpunit.dir}/lib/maven-ant-tasks-2.1.3.jar" />
        <typedef resource="org/apache/maven/artifact/ant/antlib.xml"
            uri="antlib:org.apache.maven.artifact.ant"
            classpathref="maven-ant-tasks.classpath" />

        <artifact:dependencies pathId="dependencies.classpath" 
            filesetId="dependency.fileset"
            sourcesFilesetId="sources.dependency.fileset"
            javadocFilesetId="javadoc.dependency.fileset"
            versionsId="dependency.versions"
            cacheDependencyRefs="true"
            dependencyRefsBuildFile="${gpunit.dir}/target/build-dependencies.xml"
        >

            <dependency groupId="commons-codec" artifactId="commons-codec" version="1.3" />
            <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-compress -->
            <dependency groupId="org.apache.commons" artifactId="commons-compress" version="1.8" />
            <!-- https://mvnrepository.com/artifact/com.google.code.gson/gson -->
            <dependency groupId="com.google.code.gson" artifactId="gson" version="2.3.1" />
            <!-- https://mvnrepository.com/artifact/org.hamcrest/hamcrest-core -->
            <dependency groupId="org.hamcrest" artifactId="hamcrest-core" version="1.3" />
            <!-- https://mvnrepository.com/artifact/junit/junit -->
            <dependency groupId="junit" artifactId="junit" version="4.11" />
            <!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient -->
            <dependency groupId="org.apache.httpcomponents" artifactId="httpclient" version="4.5.3" />
            <!-- https://mvnrepository.com/artifact/org.yaml/snakeyaml -->
            <dependency groupId="org.yaml" artifactId="snakeyaml" version="1.10" />
            <!-- https://mvnrepository.com/artifact/log4j/log4j -->
            <dependency groupId="log4j" artifactId="log4j" version="1.2.17" />
            
            <!-- https://mvnrepository.com/artifact/org.mockito/mockito-core -->
            <dependency groupId="org.mockito" artifactId="mockito-core" version="1.9.5" scope="test" />
            <!-- https://mvnrepository.com/artifact/org.objenesis/objenesis -->
            <dependency groupId="org.objenesis" artifactId="objenesis" version="1.0" scope="test" />
            <!-- https://mvnrepository.com/artifact/org.hamcrest/hamcrest-core -->
            <dependency groupId="org.hamcrest" artifactId="hamcrest-core" version="1.3" scope="test" />
        </artifact:dependencies>

        <path id="gpunit.classpath">
            <pathelement location="${gpunit.dir}/classes" />
            <pathelement location="${gpunit.dir}/lib/gp-modules-updated.jar" />
            <path refid="gp.client.classpath" />
            <path refid="dependencies.classpath" />
        </path>

        <copy todir="${dependency.dir}">
            <fileset refid="dependency.fileset" />
            <!-- This mapper strips off all leading directory information -->
            <mapper type="flatten" />
        </copy>

        <copy todir="${dependency.dir}/src">
            <fileset refid="sources.dependency.fileset" />
            <mapper classpathref="maven-ant-tasks.classpath"
                  classname="org.apache.maven.artifact.ant.VersionMapper"
                  from="${dependency.versions}" to="flatten" />
        </copy>

        <copy todir="${dependency.dir}/javadoc">
            <fileset refid="javadoc.dependency.fileset" />
            <mapper classpathref="maven-ant-tasks.classpath"
                  classname="org.apache.maven.artifact.ant.VersionMapper"
                  from="${dependency.versions}" to="flatten" />
        </copy>
    </target>

    <target name="compile" depends="init, gp-client-lib, download-deps"
        description="compile GpUnit">
        <property name="java.target" value="1.6" /> 
        <javac debug="true" includeantruntime="false"
            defaultexcludes="true" 
            deprecation="true" 
            destdir="${gpunit.dir}/classes" 
            optimize="false" 
            proceed="false" 
            srcdir="${gpunit.dir}/src/main/java" 
            classpathref="gpunit.classpath" >
        </javac>
    </target>

    <target name="package" depends="compile"
        description="build and package GpUnit, creates the 'gp-unit.jar' file"
        >
        <jar basedir="${gpunit.dir}/classes" jarfile="${gpunit.dir}/dist/gp-unit.jar" />
    </target>

    <target name="clean-deps"
        description="clean the 3rd party dependencies downloaded from the maven repository"
    >
        <delete dir="${dependency.dir}" />
    </target>
        
    <target name="clean-gpunit-dist" 
        description="clean the GpUnit binary distribution by deleting the class files and support libraries">
        <delete dir="${gpunit.dir}/classes" />
        <delete dir="${gpunit.dir}/dist" />
        <delete dir="${gpunit.dir}/target" />
    </target>
    
    <target name="clean-test-run" depends="clean-gpunit-outputdir, clean-report-dir"
        description="calls 'clean-gpunit-outputdir' and 'clean-report-dir'"
    >
    </target>

    <target name="clean-gpunit-outputdir"
        description="delete the '${gpunit.outputdir}', which includes all downloaded job results"
    >
        <fail unless="gpunit.outputdir" />
        <delete dir="${gpunit.outputdir}" />
        <delete file="System.out" />
    </target>

    <target name="clean-report-dir"
        description="delete the '${report.dir}'"
    >
        <fail unless="report.dir" />
        <delete dir="${report.dir}" />
    </target>

    <target name="clean" depends="clean-test-run, clean-gpunit-dist"
        description="cleans all output files, including the binary distribution"
    >
        <!-- Clean up the repositories created by imported buildsuites.xml -->
        <antcall target="clean-test-repos" />
    </target>
    <!-- END build gp-unit.jar -->

    <!--
      'curl' command line wrapper
      Usage:
        <curl url="${my-url}" />         
        <curl head="true" url="${my-url}" />
      As an alternative, pass all command line args via the 'extra-args' property ... 
          <curl extra-args="-I -s -f -S" url="${my-url}" />
          ant -Dcheck-url.extra-args="-I -s -f -S" ...
    -->
    <macrodef name="curl">
      <attribute name="url" />

      <!-- curl command line options, set these properties to "true" to enable each option -->
      <attribute name="head" default="false"
        description="-I, --head command line option" />
      <attribute name="insecure" default="false" 
        description="-k, --insecure, insecure SSL connections" />
      <attribute name="silent" default="true" 
        description="-s, --silent, don't show progress meter or error messages" />
      <attribute name="fail" default="true" 
        description="-f, --fail, fail silently on server errors and return error 22" />
      <attribute name="show-error" default="true" 
        description="-S, --show-error" />
        
      <!-- extra command line args -->
      <attribute name="extra-args" default="" />
        
      <sequential>
        <exec executable="curl"
          failifexecutionfails="false"
          failonerror="true"
          outputproperty="exec.out"
          logError="true"
        >
          <arg value="--insecure"    if:true="@{insecure}" /> 
          <arg value="--head"        if:true="@{head}" />
          <arg value="--silent"      if:true="@{silent}" />
          <arg value="--fail"        if:true="@{fail}" />
          <arg value="--show-error"  if:true="@{show-error}" />
          <arg line="@{extra-args}" unless:blank="@{extra-args}" />
          <arg value="@{url}" />
        </exec>
        </sequential>
    </macrodef>

    <!--
        Check to see if the server is online.
    -->
    <property name="check-url.head"       value="true" />
    <property name="check-url.insecure"   value="false" />
    <property name="check-url.silent"     value="true" />
    <property name="check-url.fail"       value="true" />
    <property name="check-url.show-error" value="true" />
    <property name="check-url.extra-args" value="" />
    <macrodef name="check-url">
        <attribute name="url" default="${gp.url}${gp.path}/pages/login.xhtml" />

        <attribute name="head" default="true"
            description="when true, append the '--head' flag to the curl command" />
        <attribute name="insecure" default="${check-url.insecure}" 
            description="when true, append the '--insecure' flag to the curl command" />
        <attribute name="silent" default="${check-url.silent}" />
        <attribute name="fail" default="${check-url.fail}" />
        <attribute name="show-error" default="${check-url.show-error}" />
        <sequential>
            <!-- use curl command to check status -->
            <!-- curl -I http://127.0.0.1:8080/gp/pages/login.xhtml -->
            <echo if:true="${verbose}" message="checking status, url=@{url}" />
            <curl head="${check-url.head}" 
                insecure="${check-url.insecure}" 
                silent="${check-url.silent}" 
                fail="${check-url.fail}" 
                show-error="${check-url.show-error}" 
                extra-args="${check-url.extra-args}"
                url="@{url}" 
            />
        </sequential>
    </macrodef>

    <!-- run a batch of gp-unit tests via REST client requests 
         use a single parameterized jUnit test to submit the jobs and validate the results.
         
         To run the tests, create a path, give it a refid, then create a property from that refid.
         Look at the gpunit-all-protocols target for an example. 
      -->
    <macrodef name="run-tests">
        <attribute name="junit.test.name" default="org.genepattern.gpunit.test.BatchModuleTest" />
        <attribute name="testcases" />
        <attribute name="numThreads" default="${gpunit.numThreads}" />
        <!-- when running jobs in parallel, this is the max time in seconds to wait before finishing the test -->
        <attribute name="shutdownTimeout" default="${gpunit.shutdownTimeout}" /> 
        <attribute name="junit.formatter" default="xml" /> <!-- 'brief' | 'xml' | 'html' -->
        <attribute name="showoutput" default="true" />
        <attribute name="usefile" default="true" />
        <sequential>
            <echo>Running tests as '${gp.user}' on '${gp.url}'</echo>
            <echo>testcases: @{testcases}</echo>
            <echo>junit.formatter: @{junit.formatter}</echo>

            <property name="gpunit.classpath.prop" refid="gpunit.classpath" /> 

            <junit fork="yes" printsummary="on" haltonfailure="false" showoutput="@{showoutput}" logfailedtests="true" failureProperty="test.failure" >
                <formatter type="@{junit.formatter}" usefile="@{usefile}" />
                <test name="@{junit.test.name}" outfile="TEST-all" todir="${report.run.dir}"/>
                <classpath refid="gpunit.classpath" />
                <sysproperty key="gpunit.testcase.dirs" value="@{testcases}" />

                <sysproperty key="gp.url" value="${gp.url}" />
                <sysproperty key="gp.user" value="${gp.user}" />
                <sysproperty key="gp.password" value="${gp.password}" />

                <sysproperty key="gpunit.client" value="${gpunit.client}" />
                <sysproperty key="gpunit.outputdir" value="${gpunit.outputdir}" />
                <sysproperty key="gpunit.batch.name" value="${gpunit.batch.name}" />
                <sysproperty key="gpunit.save.downloads" value="${gpunit.save.downloads}" />
                <sysproperty key="gpunit.delete.jobs" value="${gpunit.delete.jobs}" />
                
                <sysproperty key="gpunit.upload.dir" value="${gpunit.upload.dir}" />
                <sysproperty key="gpunit.server.dir" value="${gpunit.server.dir}" />
                
                <sysproperty key="gpunit.numThreads" value="@{numThreads}" />
                <sysproperty key="gpunit.shutdownTimeout" value="@{shutdownTimeout}" />
                <sysproperty key="gpunit.testTimeout" value="${gpunit.testTimeout}" />
                <sysproperty key="gpunit.jobCompletionTimeout" value="${gpunit.jobCompletionTimeout}" />
                <sysproperty key="gpunit.properties" value="${gpunit.properties}" />
                <!-- GpUnit uses project.basedir to find gpunit.default.properties -->
                <sysproperty key="project.basedir" value="${project.basedir}" />
                <syspropertyset>
                    <propertyref builtin="commandline"/>
                </syspropertyset>

                <syspropertyset refid="org.apache.commons.props" />

                <jvmarg if:set="gpunit.trustStore.has_value" 
                    value="-Djavax.net.ssl.trustStore=${gpunit.trustStore}" />
                <jvmarg if:set="gpunit.trustStorePassword.has_value" 
                    value="-Djavax.net.ssl.trustStorePassword=${gpunit.trustStorePassword}" />
            </junit>

            <junitreport todir="${report.run.dir}">
                <fileset dir="${report.run.dir}">
                    <include name="TEST-*.xml"/>
                </fileset>
                <report format="frames" todir="${report.run.dir}/html"/>
            </junitreport>

            <fail if="test.failure" message="junit test failed" />
        </sequential> 
    </macrodef>
    
    <target name="gpunit-all-protocols" depends="package"
        description="Run all GpUnit tests in the '${gpunit.dir}/tests/protocols' folder" 
    >
        <property name="protocols.dir" location="${gpunit.dir}/tests/protocols" />
        <run-tests 
            testcases="${protocols.dir}" 
            numThreads="5" 
        />
    </target>

    <target name="gpunit-all-saved-jobs" depends="package"
        description="Run all GpUnit tests in the '${gpunit.dir}/tests/saved_jobs' folder" 
    >
        <property name="saved-jobs.dir" location="{gpunit.dir}/tests/saved_jobs" />
        <run-tests testcases="${saved-jobs.dir}" />
    </target>

    <!--
      Usage:
        # run all tests in the 'gpunit' sub directory
        gpunit -Dtestcases=`pwd`/gpunit gpunit
        # run a single test in a sub directory
        gpunit -Dtestcases=`pwd`/gpunit/basic_test.yml gpunit
        # run a single test in the current working directory
        gpunit -Dtestcases=`pwd`/basic_test.yml gpunit
    -->
    <target name="gpunit-testcases" depends="package, connection-test"
        description="Run gpunit on all declared 'testcases'"
    > 
        <fail unless="gpunit.testcases" message="Missing required property 'testcases'" />
        <run-tests unless:true="${dry-run}" testcases="${gpunit.testcases}" />
    </target>

    <!--
      gpunit-git
          run the gpunit tests checked out from a module git repository
    
      Usage:
          gpunit [dry-run] -Drepo.name=repo-name [-Dgit.branch=branch-name] [-Dgit.commit=commit-ref]
      Examples:
          # run latest from 'master' branch
          gpunit -Drepo.name=txt2odf gpunit-git
          # run latest from 'develop' branch
          gpunit -Drepo.name=txt2odf -Dgit.branch=develop gpunit-git
          # run a tagged version of the tests
          gpunit -Drepo.name=txt2odf -Dgit.commit=tags/v2 gpunit-git
    -->
    <target name="gpunit-git" depends="init-testcases-git, gpunit-testcases"
        description="Run 'testcases' checked out from the git 'repo.name', 'git.branch', and 'git.commit'"
    /> 

    <target name="gpunit-single-module" depends="gpunit-git"
        description="Run all gpunit tests in the ${repo.name}/gpunit folder"
    />

    <target name="gpunit" depends="init-testcases, gpunit-testcases"
        description="Run all declared GpUnit 'gpunit.testcases', (default=tests/**/*.y*ml)"
    />

    <target name="compile-automatrix" depends="package"
        description="compile automatrix, see ./automatrix/build.xml"
        >
        <!-- For the interim, just copy the locally built gp-unit.jar over the archived one in the automatrix -->
        <!-- lib dir, and then try to compile automatrix. -->
        <copy file="${gpunit.dir}/dist/gp-unit.jar" todir="./automatrix/website/WEB-INF/lib" />
        <ant antfile="automatrix/build.xml" target="createWar" useNativeBasedir="true" />
    </target>

    <target name="gpunit-junit-tests" depends="init, package"
        description="run junit test of the GpUnit source code"
    >
        <property name="junit.results.dir" location="${gpunit.dir}/target/junit" />
        <mkdir dir="${junit.results.dir}" />
        <junit showoutput="true" printsummary="true" >
            <classpath>
                <pathelement location="${gpunit.dir}/classes"/>
                <fileset dir="${gpunit.dir}/src/test/lib" >
                    <include name="**/*.jar"/>
                </fileset>
                <path refid="dependencies.classpath" />
                <pathelement location="${client.lib.dir}/GenePattern.jar" />
            </classpath>
            <!-- example single test-case -->
            <!--
            <test name="org.genepattern.gpunit.yaml.PropertyExpansionTests" outfile="gpunit-junit" todir="${junit.results.dir}" >
                <formatter type="xml"/>
            </test>
            -->
            <!-- run all tests -->
            <batchtest fork="yes" todir="${junit.results.dir}">
                <formatter type="xml"/>
                <fileset dir="${gpunit.dir}/src/test/java">
                    <include name="**/*Test*.java"/>
                    <exclude name="**/AllTests.java"/>
                </fileset>
            </batchtest>
        </junit>
    </target>

    <!-- Import module test suite targets and fileset definitions -->
    <import file="buildsuites.xml" />

</project>
